// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name VBotPhonePublic
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFAudio
import AVFoundation
import AVKit
import CallKit
import CocoaLumberjack
import CommonCrypto
import CoreTelephony
import Foundation
import Network
import PushKit
import SQLite3
import Starscream
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
@_exported import VBotPhonePublic
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension UIKit.UIWindow.Level {
  public static let _background: UIKit.UIWindow.Level
  public static let _returnToCall: UIKit.UIWindow.Level
  public static let _callView: UIKit.UIWindow.Level
  public static let _screenBlocking: UIKit.UIWindow.Level
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: VBotPhonePublic.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping VBotPhonePublic.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus, b: VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public struct VBotLogger {
  public static func verbose(file: Swift.String = #file, function: Swift.String = #function, line: Swift.UInt = #line, filter: Swift.String? = nil, _ message: Swift.String)
  public static func debug(file: Swift.String = #file, function: Swift.String = #function, line: Swift.UInt = #line, filter: Swift.String? = nil, _ message: Swift.String)
  public static func info(file: Swift.String = #file, function: Swift.String = #function, line: Swift.UInt = #line, filter: Swift.String? = nil, _ message: Swift.String)
  public static func warning(file: Swift.String = #file, function: Swift.String = #function, line: Swift.UInt = #line, filter: Swift.String? = nil, _ message: Swift.String)
  public static func error(file: Swift.String = #file, function: Swift.String = #function, line: Swift.UInt = #line, filter: Swift.String? = nil, _ message: Swift.String)
}
extension CocoaLumberjack.DDLogFlag : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: CocoaLumberjack.DDLogFlag, rhs: CocoaLumberjack.DDLogFlag) -> Swift.Bool
}
public struct VBotLocalizedStrings {
  public var call_btn_messsage: Swift.String
  public var call_btn_mute: Swift.String
  public var call_btn_speaker: Swift.String
  public var call_calling: Swift.String
  public var call_connecting: Swift.String
  public var call_ringing: Swift.String
  public var call_title: Swift.String
  public var call_weak_signal: Swift.String
  public var call_end: Swift.String
  public var call_refused: Swift.String
  public var call_busy: Swift.String
  public var call_temporarily_unavailable: Swift.String
  public var call_failed_api: Swift.String
  public var call_failed_no_connection: Swift.String
  public var call_lost_connection: Swift.String
  public var call_permission_btn_allow: Swift.String
  public var call_permission_btn_deny: Swift.String
  public var call_permission_btn_setting: Swift.String
  public var call_permission_btn_skip: Swift.String
  public var call_permission_microphone_content: Swift.String
  public var call_permission_microphone_demied_content: Swift.String
  public var call_permission_microphone_demied_title: Swift.String
  public var call_permission_microphone_title: Swift.String
  public init(call_btn_messsage: Swift.String = "Nhắn tin", call_btn_mute: Swift.String = "Im lặng", call_btn_speaker: Swift.String = "Loa ngoài", call_calling: Swift.String = "Đang gọi...", call_connecting: Swift.String = "Đang kết nối", call_end: Swift.String = "Kết thúc", call_failed_api: Swift.String = "Không thể thực hiện cuộc gọi. Vui lòng thử lại.", call_failed_no_connection: Swift.String = "Không có mạng. Vui lòng thử lại.", call_lost_connection: Swift.String = "Mất kết nối", call_permission_btn_allow: Swift.String = "Cho phép", call_permission_btn_deny: Swift.String = "Không cho phép", call_permission_btn_setting: Swift.String = "Đi đến Cài đặt", call_permission_btn_skip: Swift.String = "Bỏ qua", call_permission_microphone_content: Swift.String = "Việc này cho phép ứng dụng thực hiện cuộc gọi miễn phí trong ứng dụng.", call_permission_microphone_demied_content: Swift.String = "Vui lòng cho phép ứng dụng truy cập \"Microphone\" trong Cài đặt điện thoại của bạn.", call_permission_microphone_demied_title: Swift.String = "Không thể thực hiện cuộc gọi do chưa có quyền truy cập “Micrô\"", call_permission_microphone_title: Swift.String = "Xanh SM muốn truy cập micrô trên thiết bị của bạn.", call_refused: Swift.String = "Người nhận từ chối cuộc gọi", call_busy: Swift.String = "Máy bận", call_temporarily_unavailable: Swift.String = "Không liên lạc được", call_ringing: Swift.String = "Đang đổ chuông...", call_title: Swift.String = "Gọi miễn phí", call_weak_signal: Swift.String = "Sóng yếu")
}
@objc public enum VBotEndCallReason : Swift.Int {
  case timeOut = -1001
  case initiationFailed = 1001
  case initiationFailed_1 = 1002
  case microphonePermissionDenied = 1003
  case invalidPhoneNumber = 1004
  case noDataFromServer = 1005
  case endCallBeforeServerStartCall = 1006
  case initiationFailed_3 = 1007
  case dataInvalid = 1008
  case initiationFailed_4 = 1009
  case authenticatedFailed = 1010
  case anotherCallInProgress = 1011
  case normal = 1012
  case decline = 1013
  case temporarilyUnavailable = 1014
  case busy = 1015
  case reportNewIncomingCallFailed = 1016
  case alertDataNotFound = 1017
  case noPushToken = 1018
  case unknownError = 1999
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol VBotPhoneDelegate {
  @objc optional func callStateChanged(state: VBotPhonePublic.VBotCallState)
  @objc optional func callStarted()
  @objc optional func callAccepted()
  @objc optional func callEnded(reason: VBotPhonePublic.VBotEndCallReason)
  @objc optional func microphonePermission(status: AVFAudio.AVAudioSession.RecordPermission)
  @objc optional func callMuteStateDidChange(muted: Swift.Bool)
  @objc optional func messageButtonTapped()
  @objc optional func networkIsUnreachable()
  @objc optional func internetConnectionChanged()
  @objc optional func showCallVC()
  @objc optional func returnToCallVC()
  @objc optional func hideCallVC()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VBotPhone : ObjectiveC.NSObject, CallKit.CXCallObserverDelegate {
  public static let sharedInstance: VBotPhonePublic.VBotPhone
  public var audioOutput: VBotPhonePublic.VBotAudioControllerOutputs?
  public var microphonePermissionGranted: AVFAudio.AVAudioSession.RecordPermission
  public var callStopped: Swift.Bool
  public var outgoingCallStarted: Swift.Bool
  public var currentMos: Swift.Double
  @objc deinit
}
extension VBotPhonePublic.VBotPhone {
  public func setup(with config: VBotPhonePublic.VBotConfig)
  public func setConfig(config: VBotPhonePublic.VBotConfig)
  public func getConfig() -> VBotPhonePublic.VBotConfig?
  public func getLocalizedStrings() -> VBotPhonePublic.VBotLocalizedStrings
  public func connect(token: Swift.String, completion: @escaping (Swift.String?, (any Swift.Error)?) -> Swift.Void)
  public func disconnect(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func isUserConnected() -> Swift.Bool
  public func userDisplayName() -> Swift.String?
  public func userToken() -> Swift.String?
  public func getHotlines(completion: @escaping ([VBotPhonePublic.VBotHotline]?, (any Swift.Error)?) -> Swift.Void)
  public func startOutgoingCall(name: Swift.String, hotline: Swift.String, number: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func startIncomingCall(callParams: VBotPhonePublic.CallParams, completion: @escaping () -> Swift.Void)
  public func isIncomingCall() -> Swift.Bool
  public func getCallName() -> Swift.String
  public func getCallState() -> VBotPhonePublic.VBotCallState
  public func returnToCallVCIfNeeded()
  public func hideCallVCIfNeeded()
  public func hasActiveCall() -> Swift.Bool
  public func endCall(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func endCallByPushkit(uuid: Foundation.UUID, completion: @escaping () -> Swift.Void)
  public func muteCall()
  public func holdCall(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func hasAudioBluetooth() -> Swift.Bool
  public func isSpeakerOn() -> Swift.Bool
  public func onOffSpeaker()
  public func isCallHold() -> Swift.Bool
  public func isCallMute() -> Swift.Bool
  public func sendDTMF(digit: Swift.String, completion: @escaping ((any Swift.Error)?) -> Swift.Void)
}
extension VBotPhonePublic.VBotPhone {
  @objc dynamic public func callObserver(_ callObserver: CallKit.CXCallObserver, callChanged call: CallKit.CXCall)
}
extension VBotPhonePublic.VBotPhone {
  public func addDelegate(_ delegate: any VBotPhonePublic.VBotPhoneDelegate)
  public func removeDelegate(_ delegate: any VBotPhonePublic.VBotPhoneDelegate)
}
extension VBotPhonePublic.VBotPhone {
  public func getActiveCall() -> VBotPhonePublic.VBotCall?
}
public struct CallParams {
  public init(uuid: Foundation.UUID, name: Swift.String, avatar: Swift.String, hotline: Swift.String, number: Swift.String, transId: Swift.String, metaData: [Swift.String : Any]? = nil, typeCall: VBotPhonePublic.TypeCall)
}
extension CoreFoundation.CGRect {
  public var x: CoreFoundation.CGFloat {
    get
    set
  }
  public var y: CoreFoundation.CGFloat {
    get
    set
  }
  public var center: CoreFoundation.CGPoint {
    get
  }
  public var topLeft: CoreFoundation.CGPoint {
    get
  }
  public var topRight: CoreFoundation.CGPoint {
    get
  }
  public var bottomLeft: CoreFoundation.CGPoint {
    get
  }
  public var bottomRight: CoreFoundation.CGPoint {
    get
  }
  public func pinnedToVerticalEdge(of boundingRect: CoreFoundation.CGRect) -> CoreFoundation.CGRect
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var left: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var right: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var top: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var bottom: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var width: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var height: CoreFoundation.CGFloat {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func animateDecelerationToVerticalEdge(withDuration duration: Foundation.TimeInterval, velocity: CoreFoundation.CGPoint, velocityThreshold: CoreFoundation.CGFloat = 500, boundingRect: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func setIsHidden(_ isHidden: Swift.Bool, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency public func setIsHidden(_ isHidden: Swift.Bool, withAnimationDuration duration: Foundation.TimeInterval, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
extension CoreFoundation.CGPoint {
  public var length: CoreFoundation.CGFloat {
    get
  }
  @inlinable public func distance(_ other: CoreFoundation.CGPoint) -> CoreFoundation.CGFloat {
        sqrt(pow(x - other.x, 2) + pow(y - other.y, 2))
    }
}
extension UIKit.UIEdgeInsets {
  public init(margin: CoreFoundation.CGFloat)
}
extension UIKit.UIView.AnimationCurve {
  public var asAnimationOptions: UIKit.UIView.AnimationOptions {
    get
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == UIKit.UIView.AnimationCurve {
  public var asAnimationOptions: UIKit.UIView.AnimationOptions {
    get
  }
}
#else
extension Swift.Optional where Wrapped == UIKit.UIView.AnimationCurve {
  public var asAnimationOptions: UIKit.UIView.AnimationOptions {
    get
  }
}
#endif
public struct VBotConfig {
  public init(iconTemplateImageData: Foundation.Data? = nil)
}
extension Foundation.NSNotification.Name {
  public static let VBotCallInfoUpdated: Foundation.Notification.Name
  public static let VBotCallStarted: Foundation.Notification.Name
  public static let VBotCallAccepted: Foundation.Notification.Name
  public static let VBotCallEnded: Foundation.Notification.Name
  public static let VBotCallMuteStateDidChange: Foundation.Notification.Name
  public static let VBotCallMessageButtonTapped: Foundation.Notification.Name
  public static let VBotCallHoldStateDidChange: Foundation.Notification.Name
}
public struct VBotHotline : Swift.Codable {
  public let name: Swift.String, phoneNumber: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum VBotReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
}
@objc public class VBotReachability : ObjectiveC.NSObject {
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable
    case reachableViaWiFi
    case reachableVia2G
    case reachableVia3G
    case reachableVia4G
    public var description: Swift.String {
      get
    }
    public static func == (a: VBotPhonePublic.VBotReachability.NetworkStatus, b: VBotPhonePublic.VBotReachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias NetworkChanged = (VBotPhonePublic.VBotReachability) -> ()
  public var whenConnectionChanged: VBotPhonePublic.VBotReachability.NetworkChanged?
  public var onWWAN: Swift.Bool
  @objc public var hasHighSpeed: Swift.Bool {
    @objc get
  }
  @objc public var statusString: Swift.String {
    @objc get
  }
  @objc public var carrierName: Swift.String? {
    @objc get
  }
  public var status: VBotPhonePublic.VBotReachability.NetworkStatus {
    get
  }
  public var radioStatus: VBotPhonePublic.VBotReachability.NetworkStatus? {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability)
  convenience public init?(hostname: Swift.String)
  convenience public init?(_: Swift.Bool)
  @objc deinit
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
extension VBotPhonePublic.VBotReachability {
  public func startNotifier() throws
  public func stopNotifier()
}
public enum SocketMethod : Swift.String, Swift.CaseIterable {
  case READY_CALL
  case UN_READY_CALL
  case HANGUP_CALL
  public init?(rawValue: Swift.String)
  public typealias AllCases = [VBotPhonePublic.SocketMethod]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [VBotPhonePublic.SocketMethod] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension VBotPhonePublic.VBotCallState {
  public var description: Swift.String {
    get
  }
}
extension AVFAudio.AVAudioSession.RecordPermission {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class VBotReachabilityHelper {
  @objc deinit
}
public enum TypeCall : Swift.String {
  case incoming
  case outgoing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension VBotPhonePublic.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension VBotPhonePublic.VBotEndCallReason : Swift.Equatable {}
extension VBotPhonePublic.VBotEndCallReason : Swift.Hashable {}
extension VBotPhonePublic.VBotEndCallReason : Swift.RawRepresentable {}
extension VBotPhonePublic.VBotReachability.NetworkStatus : Swift.Equatable {}
extension VBotPhonePublic.VBotReachability.NetworkStatus : Swift.Hashable {}
extension VBotPhonePublic.SocketMethod : Swift.Equatable {}
extension VBotPhonePublic.SocketMethod : Swift.Hashable {}
extension VBotPhonePublic.SocketMethod : Swift.RawRepresentable {}
extension VBotPhonePublic.TypeCall : Swift.Equatable {}
extension VBotPhonePublic.TypeCall : Swift.Hashable {}
extension VBotPhonePublic.TypeCall : Swift.RawRepresentable {}
